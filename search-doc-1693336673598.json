[{"title":"Considerations","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations","content":"Considerations This chapter exists to help you decide whether this library is compatible with your project and to address any concerns that you may have. You might be also interested in the Author's take","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Security","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations/security","content":"Security It is often discussed whether AsyncLocalStorage is safe to use for concurrent requests (because of a possible context leak) and whether the context could be lost throughout the duration of a request. The ClsMiddleware and ClsInterceptor by default uses the safe run() method, which it should not leak context, but in some rare cases, the context can be lost. The ClsGuard (and ClsMiddleware, if configured so) uses the less safe enterWith() method, which might be needed in case the run() method causes context loss. This has a consequence that should be taken into account: caution When the enterWith method is used, any consequent requests get access to the CLS context of the previous request until the request hits the enterWith call. That means, when using ClsMiddleware with the useEnterWith option, or ClsGuard to set up context, be sure to mount them as early in the request lifetime as possible and do not use any other enhancers that rely on ClsService before them. For ClsGuard, that means you should probably manually mount it in AppModule if you require any other guard to run after it. The next chapter addresses compatibility with various transport protocols.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"API","type":0,"sectionRef":"#","url":"/nestjs-cls/api","content":"API This chapter describes the programmatic API of the ClsService and the ClsModule options.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Service Interface","type":0,"sectionRef":"#","url":"/nestjs-cls/api/service-interface","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"ClsService​","type":1,"pageTitle":"Service Interface","url":"/nestjs-cls/api/service-interface#clsservice","content":"The injectable ClsService provides the following API to manipulate the cls context: The S type parameter is used as the type of custom ClsStore. get(): S Get the entire CLS context. get(key?: keyof S): S[key] Retrieve a value from the CLS context by key. getId(): string; Retrieve the request ID (a shorthand for cls.get(CLS_ID)) has(key: keyof S): boolean Check if a key is in the CLS context. set(key: keyof S, value: S[key]): void Set a value on the CLS context. setIfUndefined(key: keyof S, value: S[key]): void Set a value on the CLS context only if it hasn't been already set. Useful for ensuring idempotence if you have multiple entry points. run(callback: () =&gt; T): T run(options: ClsContextOptions, callback: () =&gt; T): T; Run the callback in a shared CLS context. Optionally takes an options object as the first parameter. runWith(store: S, callback: () =&gt; T): T Run the callback in a new CLS context (while supplying the default store). enter(): void; enter(options: ClsContextOptions): void Run any following code in a shared CLS context. Optionally takes an options object as the first parameter. enterWith(store: S): void Run any following code in a new CLS context (while supplying the default store). exit(callback: () =&gt; T): T Run the callback without access to a shared CLS context. isActive(): boolean Whether the current code runs within an active CLS context. resolveProxyProviders(): Promise&lt;void&gt; Manually trigger resolution of Proxy Providers. "},{"title":"ClsContextOptions​","type":1,"pageTitle":"Service Interface","url":"/nestjs-cls/api/service-interface#clscontextoptions","content":"The run and enter methods can take an additional options object with the following settings: ifNested?: 'override' | 'inherit' | 'reuse' Sets the behavior of nested CLS context creation in case the method is invoked in an existing context. It has no effect if no parent context exist. override (default) - Run the callback with an new empty context. No values from the parent context will be accessible within the wrapped code.inherit - Run the callback with a shallow copy of the parent context. Re-assignments of top-level properties will not be reflected in the parent context. However, modifications of existing properties will be reflected.reuse - Reuse existing context without creating a new one. All modifications to the existing context will be reflected. "},{"title":"Compatibility","type":0,"sectionRef":"#","url":"/nestjs-cls/considerations/compatibility","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"REST​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#rest","content":"This package is compatible with Nest-supported REST controllers and the preferred way is to use the ClsMiddleware with the mount option set to true. Tested with: ✔ Express✔ Fastify Known issues: In case API versioning is used, the automatic mounting of the ClsMiddleware does not work and it needs to be mounted manually. See issue #67 for details.Some existing Express middlewares may cause context loss, if that happens, mount the ClsMiddleware manually after those offending ones (#50) "},{"title":"GraphQL​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#graphql","content":"Using an interceptor or a guard may result in that enhancer triggering multiple times in case there are multiple queries in the GQL request. Due to this, you should ensure that any operation on the CLS store within enhancers is idempotent. This includes the setup function. Therefore, it is advised to use the ClsService#setIfUndefined() method. Tested with: ✔ Apollo (Express)✔ Mercurius (Fastify) "},{"title":"@nestjs/graphql >= 10​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#nestjsgraphql--10","content":"Since v10, Nest's GraphQL resolvers are compatible with this package and the preferred way to initialize the CLS context is use the ClsMiddleware with the mount option. "},{"title":"@nestjs/graphql < 10​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#nestjsgraphql--10-1","content":"For older versions of graphql, the ClsMiddleware needs to be mounted manually with app.use(...) in order to correctly set up the context for resolvers. Additionally, you have to pass useEnterWith: true to the ClsMiddleware options, because the context gets lost otherwise due to an issue with CLS and Apollo (sadly, the same is true for Mercurius). This method is functionally identical to just using the ClsGuard. Alternatively, you can use the ClsInterceptor, which uses the safer AsyncLocalStorage#run (thanks to andreialecu), but remember that using it makes CLS unavailable in Guards. "},{"title":"Others​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#others","content":"Use the ClsGuard or ClsInterceptor to set up context with any other platform. There are no explicit test for other transports, so I can't guarantee it will work with your platform of choice, but there's nothing that would indicate otherwise. If you decide to try this package with a platform that is not listed here, please let me know so I can add the compatibility notice. Below are listed transports with which it is confirmed to work: "},{"title":"Websockets​","type":1,"pageTitle":"Compatibility","url":"/nestjs-cls/considerations/compatibility#websockets","content":"Websocket Gateways don't respect globally bound enhancers, therefore it is required to bind the ClsGuard or ClsInterceptor manually on the WebsocketGateway. Special care is also needed for the handleConnection method (See #8) "},{"title":"NestJS CLS","type":0,"sectionRef":"#","url":"/nestjs-cls/","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Use cases​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#use-cases","content":"Some common use cases that this library enables include: Tracking the Request ID and other metadata for logging purposesKeeping track of the user throughout the whole requestMaking the dynamic Tenant database connection available everywhere in multi-tenant appsPropagating the authentication level or role to restrict access to resourcesSeamlessly propagating the transaction object of your favourite ORM across services without breaking encapsulation and isolation by explicitly passing it around.Using &quot;request&quot; context in cases where actual REQUEST-scoped providers are not supported (passport strategies, cron controllers, websocket gateways, ...) Most of these are to some extent solvable using REQUEST-scoped providers or passing the context as a parameter, but these solutions are often clunky and come with a whole lot of other issues. info * The name comes from the original implementation based on cls-hooked, which was since replaced by the native AsyncLocalStorage. "},{"title":"Motivation​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#motivation","content":"NestJS is an amazing framework, but in the plethora of awesome built-in features, I still missed one. I created this library to solve a specific use case, which was limiting access to only those records which had the same TenantId as the request's user in a central manner. The repository code automatically added a WHERE clause to each query, which made sure that other developers couldn't accidentally mix tenant data (all tenants' data were held in the same database) without extra effort. AsyncLocalStorage is still fairly new and not many people know of its existence and benefits. Here's a nice talk from NodeConf about the history. I've invested a great deal of my personal time in making the use of it as pleasant as possible. While the use of async_hooks is sometimes criticized for making Node run slower, in my experience, the introduced overhead is negligible compared to any IO operation (like a DB or external API call). If you want fast, use a compiled language. Also, if you use some tracing library (like otel), it most likely already uses async_hooks under the hood, so you might as well use it to your advantage. "},{"title":"Highlights​","type":1,"pageTitle":"NestJS CLS","url":"/nestjs-cls/#highlights","content":"New: Version 3.0 introduces Proxy Providers as an alternative to the imperative API. (Minor breaking changes were introduced, see Migration guide). Version 2.0 brings advanced type safety and type inference. However, it requires features from typescript &gt;= 4.4 - Namely allowing symbol members in interfaces. If you can't upgrade but still want to use this library, install version 1.6.2, which lacks the typing features. "},{"title":"Module Options","type":0,"sectionRef":"#","url":"/nestjs-cls/api/module-options","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"forRoot(Async)​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#forrootasync","content":"The ClsModule.forRoot() method takes the following ClsModuleOptions: middleware?: ClsMiddlewareOptions An object with additional options for the ClsMiddleware, see below. guard?: ClsGuardOptions An object with additional options for the ClsGuard, see below. interceptor?: ClsInterceptorOptions An object with additional options for the ClsInterceptor, see below. global?: boolean (default false) Whether to make the module global, so you do not have to import ClsModule.forFeature() in other modules. proxyProviders?: Type[] Array of Proxy Providers that should be registered in the root module. Currently only accepts sync class Proxy providers, use ClsModule.forFeatureAsync() for more complex use-cases. ClsModule.forRootAsync() is also available. You can supply the usual imports, inject and useFactory parameters as usual. info Please note: If you intend to use multiple enhancers at the same time (e.g. initialize the CLS context in a middleware and then set some CLS variables additional CLS variables in an interceptor), be aware that the only the first one in the chain will set the Request ID. "},{"title":"forFeature(Async)​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#forfeatureasync","content":"The ClsModule.forFeature() method can be used to register a Proxy Providers. The Sync method only accepts Class Proxy providers. The ClsModule.forFeatureAsync() method accepts either ClsModuleProxyClassProviderOptions or ClsModuleProxyFactoryProviderOptions that both accept these options: provide?: any Custom injection token to use for the provider. In case of a class provider, this parameter is optional, as the class reference passed to useClass will be used by default. imports? any[] Optional list of imported modules that export the providers which are required for the provider. extraProviders?: Provider[]Optional list of additional providers that should be available to the Proxy. Useful for passing configuration from a parent dynamic module. The ClsModuleProxyClassProviderOptions interface further accepts: useClass: Type The target class that will be used by this Proxy Provider. Make sure it is decorated with @InjectableProxy. The ClsModuleProxyFactoryProviderOptions interface further accepts: inject: any[] An array of injection tokens for providers used in the useFactory. useFactory: (...args: any[]) =&gt; any Factory function that accepts an array of providers in the order of the according tokens in the inject array. Returns (or resolves with) an object (or a function) that will be used by this Proxy Provider. "},{"title":"Middleware & Enhancer options​","type":1,"pageTitle":"Module Options","url":"/nestjs-cls/api/module-options#middleware--enhancer-options","content":"All of the Cls{Middleware,Guard,Interceptor}Options take the following parameters (either in ClsModuleOptions or directly when instantiating them manually): mount?: boolean (default false) Whether to automatically mount the middleware/guard/interceptor to every route (not applicable when instantiating them manually) generateId?: boolean (default false) Whether to automatically generate a request ID. It will be available under the CLS_ID key. idGenerator?: (req: Request) =&gt; string | Promise&lt;string&gt; idGenerator?: (ctx: ExecutionContext) =&gt; string | Promise&lt;string&gt; An optional function for generating the request ID. It takes the Request object (or the ExecutionContext in case of a Guard or Interceptor) as an argument and (synchronously or asynchronously) returns a string. The default implementation uses Math.random() to generate a string of 8 characters. setup?: (cls: ClsService, req: Request) =&gt; void | Promise&lt;void&gt;; setup?: (cls: ClsService, ctx: ExecutionContext) =&gt; void | Promise&lt;void&gt;; Function that executes after the CLS context had been initialised. It can be used to put additional variables in the CLS context. resolveProxyProviders?: boolean (default true) Whether to automatically resolve Proxy Providers in the enhancer (if any are registered). The ClsMiddlewareOptions additionally takes the following parameters: saveReq?: boolean (default true) Whether to store the Request object to the context. It will be available under the CLS_REQ key. saveRes?: boolean (default false) Whether to store the Response object to the context. It will be available under the CLS_RES key useEnterWith?: boolean (default false) Set to true to set up the context using a call to AsyncLocalStorage#enterWith instead of wrapping the next() call with the safer AsyncLocalStorage#run. Most of the time this should not be necessary, but some frameworks are known to lose the context with run. "},{"title":"Breaking out of DI","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/breakin-out-of-di","content":"Breaking out of DI While this package aims to be compatible with NestJS's Dependency Injection, it is also possible to access the CLS context outside of it. For that, it provides the static ClsServiceManager class that exposes the getClsService() method which can be used to retrieve the context outside of Nest's injection context (e.g. in top-level functions) function helper() { const cls = ClsServiceManager.getClsService(); // you now have access to the shared storage console.log(cls.getId()); } caution Please note: Only use this feature where absolutely necessary. Using this technique instead of dependency injection will make it difficult to mock the ClsService and your code will become harder to test.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Features and use cases","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases","content":"Features and use cases In addition to the basic functionality described in the Quick start chapter, this module provides several other features to make your life as a developer easier.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Additional CLS Setup","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Middleware​","type":1,"pageTitle":"Additional CLS Setup","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup#middleware","content":"In case of middleware the Request and Response objects are passed as the second and third parameters. ClsModule.forRoot({ middleware: { mount: true, setup: (cls, req: Request, res: Response) =&gt; { cls.set('TENANT_ID', req.params('tenant_id')); cls.set('AUTH', { authenticated: false }); }, }, });  "},{"title":"Enhancers​","type":1,"pageTitle":"Additional CLS Setup","url":"/nestjs-cls/features-and-use-cases/additional-cls-setup#enhancers","content":"In a guard or interceptor, the ExecutionContext object is passed as a second parameter. ClsModule.forRoot({ interceptor: { mount: true, setup: (cls, context) =&gt; { const req = context.switchToHttp().getRequest&lt;Request&gt;(); cls.set('TENANT_ID', req.params('tenant_id')); cls.set('AUTH', { authenticated: false }); }, }, });  "},{"title":"Installation","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/installation","content":"Installation Install as any other NPM package using your favorite package manager. npmyarnpnpm npm install nestjs-cls info This module requires additional peer deps, like the @nestjs/core and @nestjs/common libraries, but it is assumed those are already installed.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Migration guide","type":0,"sectionRef":"#","url":"/nestjs-cls/migration-guide","content":"Migration guide In case you're upgrading to a new major version of this library, follow the according migration guide.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Request ID","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/request-id","content":"Request ID Because of a shared storage, CLS is an ideal tool for tracking request (correlation) IDs for the purpose of logging. This package provides an option to automatically generate request IDs in the middleware/guard/interceptor, if you pass { generateId: true } to its options. By default, the generated ID is a string based on Math.random(), but you can provide a custom function in the idGenerator option. This function receives the Request (or ExecutionContext in case a ClsGuard is used) as the first parameter, which can be used in the generation process and should return (or resolve with) a string ID that will be stored in the CLS for later use. Below is an example of retrieving the request ID from the request header with a fallback to an autogenerated one. ClsModule.forRoot({ middleware: { mount: true, generateId: true, idGenerator: (req: Request) =&gt; req.headers['X-Request-Id'] ?? uuid(); } }) The ID is stored under the CLS_ID constant in the context. The ClsService provides a shorthand method getId to quickly retrieve it anywhere. It can be for example used in a custom logger: my.logger.ts @Injectable() class MyLogger { constructor(private readonly cls: ClsService) {} log(message: string) { console.log(`&lt;${this.cls.getId()}&gt; ${message}`); } } Calling this from anywhere within a CLS context results in retrieving the ID: my.service.ts @Injectable() class MyService { constructor(private readonly logger: MyLogger); hello() { this.logger.log('Hello'); // -&gt; logs for ex.: &quot;&lt;44c2d8ff-49a6-4244-869f-75a2df11517a&gt; Hello&quot; } } ","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"How it works","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/how-it-works","content":"How it works Continuation-local storage provides a common space for storing and retrieving data throughout the life of a function/callback call chain. In NestJS, this allows for sharing request data across the lifetime of a single request - without the need for request-scoped providers. It also makes it easy to track and log request ids throughout the whole application. To make CLS work, it is required to set up the CLS context first. This is done by calling cls.run() (or cls.enter(), see Security considerations for more info) somewhere in the app. Once that is set up, anything that is called within the same callback chain has access to the same storage with cls.set() and cls.get().","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"v2.x → v3.x","type":0,"sectionRef":"#","url":"/nestjs-cls/migration-guide/v2x-v3x","content":"v2.x → v3.x The root registration method was renamed from register (resp. registerAsync) to forRoot (resp. forRootAsync) to align with the convention. - ClsModule.register({ + ClsModule.forRoot({ middleware: { mount: true }, }), Namespace injection support with forFeature was dropped entirely, and now that method is used to register Proxy Providers. If you still have a use case for namespaces, you can create a namespaced ClsService and use a custom provider to inject it. Example: class MyContextService extends ClsService&lt;MyStore&gt; {} const myContextService = new MyContextService(new AsyncLocalStorage()); // [...] providers: [ { provide: MyContextService, useValue: myContextService, }, ]; ","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Usage outside of web request","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/usage-outside-of-web-request","content":"Usage outside of web request Sometimes, a part of the app that relies on the CLS storage might need to be called outside of the context of a web request - for example, in a Cron job, while consuming a Queue or during the application bootstrap. In such cases, there are no enhancers that can be bound to the handler to set up the context. Therefore, you as the the developer are responsible for wrapping the execution with ClsService#run, or using the @UseCls decorator. In any case, if any following code depends on some context variables, these need to be set up manually. @Injectable() export class CronController { constructor( private readonly someService: SomeService, private readonly cls: ClsService, ); @Cron('45 * * * * *') async handleCronExample1() { // either explicitly wrap the function body with // a call to `ClsService#run` ... await this.cls.run(async () =&gt; { this.cls.set('mode', 'cron'); await this.someService.doTheThing(); }); } @Cron('90 * * * * *') // ... or use the convenience decorator which // does the wrapping for you seamlessly. @UseCls({ setup: (cls) =&gt; { cls.set('mode', 'cron'); }, }) async handleCronExample2() { await this.someService.doTheThing(); } } caution Special care must be taken in case you're using Proxy Providers.","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Setting up the CLS context","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Sync​","type":1,"pageTitle":"Setting up the CLS context","url":"/nestjs-cls/setting-up-cls-context#sync","content":"app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true, generateId: true, }, }), ], // ... }) export class AppModule {}  "},{"title":"Async​","type":1,"pageTitle":"Setting up the CLS context","url":"/nestjs-cls/setting-up-cls-context#async","content":"app.module.ts @Module({ imports: [ ClsModule.forRootAsync({ global: true, inject: [IdGeneratorService] useFactory: (idGeneratorService) =&gt; ({ middleware: { mount: true, generateId: true, idGenerator: (req) =&gt; idGeneratorService.generate(req) }, }) }), ], // ... }) export class AppModule {}  "},{"title":"Using a Decorator","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-decurator","content":"Using a Decorator The @UseCls() decorator can be used at a method level to declaratively wrap the method with a cls.run() call. This method should only be used outside of the context of a web request. info Please keep in mind, that since the CLS context initialization can be async, the @UseCls() decorator can only be used on async function (those that return a Promise).","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Using a Guard","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-guard","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Automatically​","type":1,"pageTitle":"Using a Guard","url":"/nestjs-cls/setting-up-cls-context/using-a-guard#automatically","content":"Use mount: true app.module.ts @Module({ imports: [ ClsModule.forRoot({ guard: { mount: true }, }), ], // ... }) export class AppModule {}  "},{"title":"Manually​","type":1,"pageTitle":"Using a Guard","url":"/nestjs-cls/setting-up-cls-context/using-a-guard#manually","content":"If you need any other guards to use the ClsService, it's preferable to mount ClsGuard manually as the first guard in the root module: app.module.ts @Module({ imports: [ ClsModule.forRoot({ guard: { mount: false } }), ] providers: [ { provide: APP_GUARD, useClass: ClsGuard, }, ], // ... }) export class AppModule {}  or mount it directly on the Controller/Resolver with @UseGuards(ClsGuard);  caution Please note: since the ClsGuard uses the AsyncLocalStorage#enterWith method, using the ClsGuard comes with some security considerations! "},{"title":"Type safety and type inference","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Type-safe ClsService​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#type-safe-clsservice","content":"It is possible to specify a custom interface for the ClsService and get proper typing and automatic type inference when retrieving or setting values. This works even for nested objects using a dot notation. To create a typed CLS Store, start by creating an interface that extends ClsStore. my-cls-service.interface.ts export interface MyClsStore extends ClsStore { tenantId: string; user: { id: number; authorized: boolean; }; }  "},{"title":"Using a type parameter​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-a-type-parameter","content":"Then you can inject the ClsService with a type parameter ClsService&lt;MyClsStore&gt; to make use of the safe typing. export class MyService { constructor(private readonly cls: ClsService&lt;MyClsStore&gt;) {} doTheThing() { // a boolean type will be enforced here this.cls.set('user.authorized', true); // tenantId will be inferred as a string const tenantId = this.cls.get('tenantId'); // userId will be inferred as a number const userId = this.cls.get('user.id'); // user will be inferred as { id: number, authorized: boolean } const user = this.cls.get('user'); // you'll even get intellisense for the keys, because the type // will be inferred as: // symbol | 'tenantId˙ | 'user' | 'user.id' | 'user.authorized' // alternatively, since the `get` method returns the whole store // when called without arguments, you can use object destructuring const { tenantId, user } = this.cls.get(); // accessing a nonexistent property will result in a type error const notExist = this.cls.get('user.name'); } }  "},{"title":"Using Typescript module augmentation​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-typescript-module-augmentation","content":"Alternatively, if you feel like using ClsService&lt;MyClsStore&gt; everywhere is tedious, you can instead globally augment the ClsStore interface. Now you don't need to specify the type parameter on ClsService to still get the string typing. declare module 'nestjs-cls' { interface ClsStore { tenantId: string; user: { id: number; authorized: boolean; }; } }  "},{"title":"Using a custom provider​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#using-a-custom-provider","content":"For even more transparent approach without augmenting the declaration, you can create a typed ClsService by extending it and creating a custom provider out of it: export class MyClsService extends ClsService&lt;MyClsStore&gt; {} @Module({ imports: [ClsModule.forFeature()], providers: [ { provide: MyClsService, useExisting: ClsService, }, ], exports: [MyClsService], }) class MyClsModule {}  Now you can inject MyClsService as an alias for ClsService&lt;MyClsStore&gt; without &quot;polluting&quot; the global type space. "},{"title":"Terminal Type​","type":1,"pageTitle":"Type safety and type inference","url":"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference#terminal-type","content":"It can happen, that the object you want to store in the context is too complex, or contains cyclic references. In that case, typescript might complain that type instantiation is too deep, possibly infinite. That is due to the fact that it tries to generate all possible paths inside the ClsStore. If that's the case, you can use the Terminal type to stop generating the paths for a certain subtree: interface ClsStore { tenantId: string; user: Terminal&lt;{ id: number; authorized: boolean; }&gt;; }  This will only generate the paths tenantId | user and won't allow directly accessing nested keys (like cls.get('user.id'), but you'll still get fully typing for things like const { id } = cls.get('user')). See issue #22 for more details. "},{"title":"Using an Interceptor","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-an-interceptor","content":"Using an Interceptor Another place to initiate the CLS context is an ClsInterceptor, which, unlike the ClsGuard uses AsyncLocalStorage#run method to wrap the following code, which is considered safer than enterWith. To use it, pass its configuration to the interceptor property to the ClsModule.forRoot() options: Automatically app.module.ts @Module({ imports: [ ClsModule.forRoot({ interceptor: { mount: true }, }), ], // ... }) export class AppModule {} Manually Or mount it manually as APP_INTERCEPTOR app.module.ts @Module({ imports: [ ClsModule.forRoot({ interceptor: { mount: false } }), ] providers: [ { provide: APP_INTERCEPTOR, useClass: ClsGuard, }, ], // ... }) export class AppModule {} or directly on the Controller/Resolver with: @UseInterceptors(ClsInterceptor); note Please note: Since Nest's Interceptors run after Guards, that means using this method makes CLS unavailable in Guards (and in case of REST Controllers, also in Exception Filters).","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Using a Middleware","type":0,"sectionRef":"#","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Automatically​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#automatically","content":"app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true }, }), ], // ... }) export class AppModule {}  "},{"title":"Manually​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#manually","content":"Sometimes, you might want to only use CLS on certain routes, or you need to have more control over the order of middleware registration in combination with other middlewares. "},{"title":"In the module​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#in-the-module","content":"In that case, omit the mount option or set it to false and bind the ClsMiddleware manually in the module: app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: false }, }), ], // ... }) export class AppModule implements NestModule { configure(consumer: MiddlewareConsumer) { consumer.apply(ClsMiddleware).forRoutes('custom/route'); } }  "},{"title":"Using app.use​","type":1,"pageTitle":"Using a Middleware","url":"/nestjs-cls/setting-up-cls-context/using-a-middleware#using-appuse","content":"Sometimes, however, the previous method won't be enough, because the middleware could be mounted too late and you won't be able to use it in other middlewares that need to run prior to that - for example, the API versioning feature of NestJS apparently interferes with the order, see issue #67. In that case, you can mount it directly in the bootstrap method: main.ts function bootstrap() { const app = await NestFactory.create(AppModule); // create and mount the middleware manually here app.use( new ClsMiddleware({ /* ...settings */ }).use, ); await app.listen(3000); }  caution Please note: If you bind the middleware using app.use(), it will not respect middleware settings passed to ClsModule.forRoot(), so you will have to provide them yourself in the constructor. "},{"title":"Quick Start","type":0,"sectionRef":"#","url":"/nestjs-cls/introduction/quick-start","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Background​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#background","content":"This library exposes a dynamic ClsModule which exposes the injectable ClsService and provides means to setting up and interacting with the CLS context. The CLS context is a storage that wraps around a chain of function calls. It can be accessed anywhere during the lifecycle of such chain via the ClsService. "},{"title":"Example​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#example","content":"Below is an example of using this library to store the client's IP address in an interceptor and retrieving it in a service without explicitly passing it along. note This example assumes you are using HTTP and therefore can use middleware. For usage with non-HTTP transports, see Setting up CLS context. "},{"title":"Register the ClsModule​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#register-the-clsmodule","content":"Register the ClsModule and automatically mount the ClsMiddleware which wraps the entire request in a shared CLS context on all routes. app.module.ts @Module({ imports: [ ClsModule.forRoot({ global: true, middleware: { mount: true }, }), ], providers: [AppService], controllers: [AppController], }) export class AppModule {}  "},{"title":"Create IP-address interceptor​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#create-ip-address-interceptor","content":"Create an interceptor that injects the ClsService to get access to the current shared CLS context,extract the users's IP address from the request and stores it into the CLS context, user-ip.interceptor.ts @Injectable() export class UserIpInterceptor implements NestInterceptor { constructor(private readonly cls: ClsService) {} intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const request = context.switchToHttp().getRequest(); const userIp = request.connection.remoteAddress; this.cls.set('ip', userIp); return next.handle(); } }  "},{"title":"Mount interceptor to controller​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#mount-interceptor-to-controller","content":"By mounting the UserIpInterceptor on the controller, it gets access to the same shared CLS context that the ClsMiddleware set up. Of course, we could also bind the interceptor globally with APP_INTERCEPTOR. app.controller.ts @UseInterceptors(UserIpInterceptor) @Injectable() export class AppController { constructor(private readonly appService: AppService) {} @Get('/hello') hello() { return this.appService.sayHello(); } }  "},{"title":"Access CLS context in service​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#access-cls-context-in-service","content":"In the AppService, we can retrieve the user's IP from the CLS context without explicitly passing in anything, and without making the AppService request-scoped! app.service.ts @Injectable() export class AppService { constructor(private readonly cls: ClsService) {} sayHello() { const userIp = this.cls.get('ip'); return 'Hello ' + userIp + '!'; } }  "},{"title":"That's it​","type":1,"pageTitle":"Quick Start","url":"/nestjs-cls/introduction/quick-start#thats-it","content":"This is pretty much all there is to it. This library further provides more quality-of-life features, so read on! info If your use-case is really simple, you can instead consider creating a custom implementation with AsyncLocalStorage. Limiting the number of dependencies in your application is always a good idea! "},{"title":"Proxy Providers","type":0,"sectionRef":"#","url":"/nestjs-cls/features-and-use-cases/proxy-providers","content":"","keywords":"async  context  request  scope  cls  asynclocalstorage  nestjs  proxy"},{"title":"Class Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#class-proxy-providers","content":"These providers look like your regular class providers, with the exception that is the @InjectableProxy() decorator to make them easily distinguishable. user.proxy.ts @InjectableProxy() export class User { id: number; role: string; }  To register the proxy provider, use the ClsModule.forFeature() registration, which exposes it an injectable provider in the parent module. ClsModule.forFeature(User);  It can be then injected using the class name. However, what will be actually injected is not the instance of the class, but rather the Proxy which redirects all access to an unique instance stored in the CLS context. "},{"title":"Populate in an enhancer​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#populate-in-an-enhancer","content":"A Class provider defined in this way will be empty upon creation, so we must assign context values to it somewhere. One place to do it is an interceptor user.interceptor.ts @Injectable() export class UserInterceptor implements NestInterceptor { // we can inject the proxy here constructor(private readonly user: User) {} intercept(context: ExecutionContext, next: CallHandler): Observable&lt;any&gt; { const request = context.switchToHttp().getRequest(); // and assign or change values as it was a normal object this.user.id = request.user.id; this.user.role = 'admin'; return next.handle(); } }  "},{"title":"Self-populating Proxy Provider​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#self-populating-proxy-provider","content":"It is also possible to inject other providers into the Proxy Provider to avoid having to do this in a separate component. For the convenience, the CLS_REQ and CLS_RES are also made into Proxy Providers and are exported from the ClsModule. user-with-rile.proxy.ts @InjectableProxy() export class UserWithRole { id: number; role: string; constructor( @Inject(CLS_REQ) request: Request, roleService: RoleService, ) { this.id = request.user.id; this.role = roleService.getForId(request.user.id); } }  If you need to inject a provider from an external module, use the ClsModule.forFeatureAsync() registration to import the containing module. ClsModule.forFeatureAsync({ // make RoleService available to the Proxy provider import: [RoleModule], useClass: UserWithRole, });  tip Using @Inject(CLS_REQ), you can entirely replace @Inject(REQUEST) in REQUEST-SCOPED providers to turn them into CLS-enabled singletons without changing the implementation. "},{"title":"Factory Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#factory-proxy-providers","content":"Like your normal factory providers, Proxy factory providers look familiar. Here's an example of a hypothetical factory provider that dynamically resolves to a specific tenant database connection: ClsModule.forFeature({ provide: TENANT_CONNECTION, import: [DatabaseConnectionModule], inject: [CLS_REQ, DatabaseConnectionService], useFactory: async (req: Request, dbService: DatabaseConnectionService) =&gt; { const tenantId = req.params['tenantId']; const connection = await dbService.getTenantConnection(tenantId); return connection; }, });  Again, the factory will be called on each request and the result will be stored in the CLS context. The TENANT_CONNECTION provider, however, will still be a singleton and will not affect the scope of whatever it is injected into. In the service, it can be injected using the provide token as usual: dogs.service.ts @Injectable() class DogsService { constructor( @Inject(TENANT_CONNECTION) private readonly connection: TenantConnection, ) {} getAll() { return this.connection.dogs.getAll(); } }  "},{"title":"Caveats​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#caveats","content":""},{"title":"No primitive values​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#no-primitive-values","content":"Proxy Factory providers cannot return a primitive value. This is because the provider itself is the Proxy and it only delegates access once a property or a method is called on it (or if it itself is called in case the factory returns a function). "},{"title":"typeof Proxies is always function​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#typeof-proxies-is-always-function","content":"In order to support injecting proxies of functions, the underlying proxy target is an empty function, too. It must be this way in order to be able to implement the &quot;apply&quot; trap. As a result of this, calling typeof on an instance of a Proxy will always return function, regardless of the value it holds. This is fine for most applications, but must be taken into consideration in some cases - please see Issue #82 for more info and possible workarounds. "},{"title":"Delayed resolution of Proxy Providers​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#delayed-resolution-of-proxy-providers","content":"By default, proxy providers are resolved as soon as the setup function in an enhancer (middleware/guard/interceptor) finishes. For some use cases, it might be required that the resolution is delayed until some later point in the request lifecycle once more information is present in the CLS . To achieve that, set resolveProxyProviders to false in the enhancer options and call ClsService#resolveProxyProviders() manually at any time. ClsModule.forRoot({ middleware: { resolveProxyProviders: false, }, });  "},{"title":"Outside web request​","type":1,"pageTitle":"Proxy Providers","url":"/nestjs-cls/features-and-use-cases/proxy-providers#outside-web-request","content":"This is also necessary outside the context of web request, otherwise all access to an injected Proxy Provider will return undefined. With cls.run()​ If you set up the context with cls.run() to wrap any subsequent code thar relies on Proxy Providers. cron.controller.ts @Injectable() export class CronController { constructor( private readonly someService: SomeService, private readonly cls: ClsService, ); @Cron('45 * * * * *') async handleCron() { await this.cls.run(async () =&gt; { // prepare the context this.cls.set('some-key', 'some-value'); // trigger Proxy Provider resolution await this.cls.resolveProxyProviders(); await this.someService.doTheThing(); }); } }  With @UseCls()​ The resolveProxyProviders is set to false by default on the @UseCls decorator. To achieve the same behavior using it, you must set it to true. The Proxy Providers will be resolved after the setup phase. cron.controller.ts @Injectable() export class CronController { constructor(private readonly someService: SomeService); @Cron('45 * * * * *') @UseCls({ resolveProxyProviders: true, setup: (cls) =&gt; { this.cls.set('some-key', 'some-value'); }, }) async handleCron() { await this.someService.doTheThing(); } }  "}]