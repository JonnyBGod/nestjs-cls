"use strict";(self.webpackChunknestjs_cls_docs=self.webpackChunknestjs_cls_docs||[]).push([[437],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),h=o,m=d["".concat(l,".").concat(h)]||d[h]||u[h]||a;return n?r.createElement(m,s(s({ref:t},p),{},{components:n})):r.createElement(m,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=h;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[d]="string"==typeof e?e:o,s[1]=i;for(var c=2;c<a;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1616:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var r=n(7462),o=(n(7294),n(3905));const a={},s="Proxy Providers",i={unversionedId:"features-and-use-cases/proxy-providers",id:"features-and-use-cases/proxy-providers",title:"Proxy Providers",description:"Since v3.0",source:"@site/docs/03_features-and-use-cases/06_proxy-providers.md",sourceDirName:"03_features-and-use-cases",slug:"/features-and-use-cases/proxy-providers",permalink:"/nestjs-cls/features-and-use-cases/proxy-providers",draft:!1,editUrl:"https://github.com/Papooch/nestjs-cls/tree/main/docs/docs/03_features-and-use-cases/06_proxy-providers.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{},sidebar:"documentationSidebar",previous:{title:"Type safety and type inference",permalink:"/nestjs-cls/features-and-use-cases/type-safety-and-type-inference"},next:{title:"API",permalink:"/nestjs-cls/api/"}},l={},c=[{value:"Class Proxy Providers",id:"class-proxy-providers",level:2},{value:"Populate in an enhancer",id:"populate-in-an-enhancer",level:3},{value:"Self-populating Proxy Provider",id:"self-populating-proxy-provider",level:3},{value:"Factory Proxy Providers",id:"factory-proxy-providers",level:2},{value:"Delayed resolution of Proxy Providers",id:"delayed-resolution-of-proxy-providers",level:2},{value:"Outside web request",id:"outside-web-request",level:3},{value:"With cls.run()",id:"with-clsrun",level:4},{value:"With @UseCls()",id:"with-usecls",level:4}],p={toc:c},d="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(d,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"proxy-providers"},"Proxy Providers"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Since ",(0,o.kt)("inlineCode",{parentName:"p"},"v3.0"))),(0,o.kt)("p",null,"This feature was inspired by how REQUEST-scoped providers (",(0,o.kt)("em",{parentName:"p"},'"beans"'),") work in the Spring framework for Java/Kotlin."),(0,o.kt)("p",null,"Using this technique, NestJS does not need to re-create a whole DI-subtree on each request (which has ",(0,o.kt)("a",{parentName:"p",href:"https://docs.nestjs.com/fundamentals/injection-scopes#scope-hierarchy"},"certain implications which disallows the use of REQUEST-scoped providers in certain situations"),")."),(0,o.kt)("p",null,"Rather, it injects a ",(0,o.kt)("em",{parentName:"p"},"SINGLETON")," ",(0,o.kt)("a",{parentName:"p",href:"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy"},"Proxy")," instance, which delegates access and calls to the actual instance, which is created for each request when the CLS context is set up."),(0,o.kt)("p",null,"There are two kinds of Proxy providers - ",(0,o.kt)("a",{parentName:"p",href:"#class-proxy-providers"},(0,o.kt)("em",{parentName:"a"},"Class"))," and ",(0,o.kt)("a",{parentName:"p",href:"#factory-proxy-providers"},(0,o.kt)("em",{parentName:"a"},"Factory")),"."),(0,o.kt)("h2",{id:"class-proxy-providers"},"Class Proxy Providers"),(0,o.kt)("p",null,"These providers look like your regular class providers, with the exception that is the ",(0,o.kt)("inlineCode",{parentName:"p"},"@InjectableProxy()")," decorator to make them easily distinguishable."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=user.proxy.ts",title:"user.proxy.ts"},"// highlight-start\n@InjectableProxy()\n// highlight-end\nexport class User {\n    id: number;\n    role: string;\n}\n")),(0,o.kt)("p",null,"To register the proxy provider, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ClsModule.forFeature()")," registration,\nwhich exposes it an injectable provider in the parent module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ClsModule.forFeature(User);\n")),(0,o.kt)("p",null,"It can be then injected using the class name."),(0,o.kt)("p",null,"However, what will be actually injected ",(0,o.kt)("em",{parentName:"p"},"is not")," the instance of the class, but rather the Proxy which redirects all access to an unique instance stored in the CLS context."),(0,o.kt)("h3",{id:"populate-in-an-enhancer"},"Populate in an enhancer"),(0,o.kt)("p",null,"A Class provider defined in this way will be empty upon creation, so we must assign context values to it somewhere. One place to do it is an interceptor"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=user.interceptor.ts",title:"user.interceptor.ts"},"@Injectable()\nexport class UserInterceptor implements NestInterceptor {\n    // we can inject the proxy here\n    // highlight-start\n    constructor(private readonly user: User) {}\n    // highlight-end\n\n    intercept(context: ExecutionContext, next: CallHandler): Observable<any> {\n        const request = context.switchToHttp().getRequest();\n\n        // and assign or change values as it was a normal object\n        // highlight-start\n        this.user.id = request.user.id;\n        this.user.role = 'admin';\n        // highlight-end\n\n        return next.handle();\n    }\n}\n")),(0,o.kt)("h3",{id:"self-populating-proxy-provider"},"Self-populating Proxy Provider"),(0,o.kt)("p",null,"It is also possible to inject other providers into the Proxy Provider to avoid having to do this in a separate component."),(0,o.kt)("p",null,"For the convenience, the ",(0,o.kt)("inlineCode",{parentName:"p"},"CLS_REQ")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"CLS_RES")," are also made into Proxy Providers and are exported from the ",(0,o.kt)("inlineCode",{parentName:"p"},"ClsModule"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=user-with-rile.proxy.ts",title:"user-with-rile.proxy.ts"},"@InjectableProxy()\nexport class UserWithRole {\n    id: number;\n    role: string;\n\n    constructor(\n        // highlight-start\n        @Inject(CLS_REQ) request: Request,\n        // highlight-end\n        roleService: RoleService,\n    ) {\n        this.id = request.user.id;\n        this.role = roleService.getForId(request.user.id);\n    }\n}\n")),(0,o.kt)("p",null,"If you need to inject a provider from an external module, use the ",(0,o.kt)("inlineCode",{parentName:"p"},"ClsModule.forFeatureAsync()")," registration to import the containing module."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ClsModule.forFeatureAsync({\n    // make RoleService available to the Proxy provider\n    import: [RoleModule],\n    useClass: UserWithRole,\n});\n")),(0,o.kt)("admonition",{type:"tip"},(0,o.kt)("p",{parentName:"admonition"},"Using ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject(CLS_REQ)"),", you can entirely replace ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject(REQUEST)")," in REQUEST-SCOPED providers to turn them into CLS-enabled singletons without changing the implementation.")),(0,o.kt)("h2",{id:"factory-proxy-providers"},"Factory Proxy Providers"),(0,o.kt)("p",null,"Like your normal factory providers, Proxy factory providers look familiar."),(0,o.kt)("p",null,"Here's an example of a hypothetical factory provider that dynamically resolves to a specific tenant database connection:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ClsModule.forFeature({\n    provide: TENANT_CONNECTION,\n    import: [DatabaseConnectionModule],\n    inject: [CLS_REQ, DatabaseConnectionService],\n    useFactory: async (req: Request, dbService: DatabaseConnectionService) => {\n        const tenantId = req.params['tenantId'];\n        const connection = await dbService.getTenantConnection(tenantId);\n        return connection;\n    },\n});\n")),(0,o.kt)("p",null,"Again, the factory will be called on each request and the result will be stored in the CLS context. The ",(0,o.kt)("inlineCode",{parentName:"p"},"TENANT_CONNECTION")," provider, however, will still be a singleton and will not affect the scope of whatever it is injected into."),(0,o.kt)("p",null,"In the service, it can be injected using the ",(0,o.kt)("inlineCode",{parentName:"p"},"provide")," token as usual:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=dogs.service.ts",title:"dogs.service.ts"},"@Injectable()\nclass DogsService {\n    constructor(\n        @Inject(TENANT_CONNECTION)\n        private readonly connection: TenantConnection,\n    ) {}\n\n    getAll() {\n        return this.connection.dogs.getAll();\n    }\n}\n")),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},(0,o.kt)("strong",{parentName:"p"},"Please note"),": Proxy Factory providers ",(0,o.kt)("em",{parentName:"p"},"cannot")," return a ",(0,o.kt)("em",{parentName:"p"},"primitive value"),". This is because the provider itself is the Proxy and it only delegates access once a property or a method is called on it (or if it itself is called in case the factory returns a function).")),(0,o.kt)("h2",{id:"delayed-resolution-of-proxy-providers"},"Delayed resolution of Proxy Providers"),(0,o.kt)("p",null,"By default, proxy providers are resolved as soon as the ",(0,o.kt)("inlineCode",{parentName:"p"},"setup")," function in an enhancer (middleware/guard/interceptor) finishes. For some use cases, it might be required that the resolution is delayed until some later point in the request lifecycle once more information is present in the CLS ."),(0,o.kt)("p",null,"To achieve that, set ",(0,o.kt)("inlineCode",{parentName:"p"},"resolveProxyProviders")," to ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," in the enhancer options and call ",(0,o.kt)("inlineCode",{parentName:"p"},"ClsService#resolveProxyProviders()")," manually at any time."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"ClsModule.forRoot({\n    middleware: {\n        // highlight-start\n        resolveProxyProviders: false,\n        // highlight-end\n    },\n});\n")),(0,o.kt)("h3",{id:"outside-web-request"},"Outside web request"),(0,o.kt)("p",null,"This is also necessary ",(0,o.kt)("a",{parentName:"p",href:"/nestjs-cls/features-and-use-cases/usage-outside-of-web-request"},"outside the context of web request"),", otherwise all access to an injected Proxy Provider will return ",(0,o.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,o.kt)("h4",{id:"with-clsrun"},"With cls.run()"),(0,o.kt)("p",null,"If you set up the context with ",(0,o.kt)("inlineCode",{parentName:"p"},"cls.run()")," to wrap any subsequent code thar relies on Proxy Providers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cron.controller.ts",title:"cron.controller.ts"},"@Injectable()\nexport class CronController {\n    constructor(\n        private readonly someService: SomeService,\n        private readonly cls: ClsService,\n    );\n\n    @Cron('45 * * * * *')\n    async handleCron() {\n        await this.cls.run(async () => {\n            // prepare the context\n            this.cls.set('some-key', 'some-value');\n            // highlight-start\n            // trigger Proxy Provider resolution\n            await this.cls.resolveProxyProviders();\n            // highlight-end\n            await this.someService.doTheThing();\n        });\n    }\n}\n")),(0,o.kt)("h4",{id:"with-usecls"},"With @UseCls()"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"resolveProxyProviders")," is set to ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," by default on the ",(0,o.kt)("inlineCode",{parentName:"p"},"@UseCls")," decorator. To achieve the same behavior using it, you must set it to ",(0,o.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,o.kt)("p",null,"The Proxy Providers will be resolved after the ",(0,o.kt)("inlineCode",{parentName:"p"},"setup")," phase."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title=cron.controller.ts",title:"cron.controller.ts"},"@Injectable()\nexport class CronController {\n    constructor(private readonly someService: SomeService);\n\n    @Cron('45 * * * * *')\n    @UseCls({\n        // highlight-start\n        resolveProxyProviders: true,\n        setup: (cls) => {\n            this.cls.set('some-key', 'some-value');\n        },\n        // highlight-end\n    })\n    async handleCron() {\n        await this.someService.doTheThing();\n    }\n}\n")))}u.isMDXComponent=!0}}]);